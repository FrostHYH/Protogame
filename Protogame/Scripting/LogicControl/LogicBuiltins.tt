<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>
// <auto-generated />
namespace LogicControl
{
    using System;
    using Microsoft.Xna.Framework;

    public static class LogicBuiltins
    {
<#

/*
        DirectVectorAndMathHelperSingle,
        DirectVectorAndMathHelperSingleAndMatrix,
        DirectVectorAndMathSingle,
        IndirectVectorAndMathHelperSingle,
        IndirectVectorAndMathSingle,
        VectorOnly,
        VectorAndMatrixOnly,
        Vector3Only*/

    var definitions = new[]
    {
        new BuiltinDefinition("Max", 2, 0, BuiltinType.DirectVectorAndMathHelperSingle), 
        new BuiltinDefinition("Min", 2, 0, BuiltinType.DirectVectorAndMathHelperSingle),
        new BuiltinDefinition("Lerp", 2, 1, BuiltinType.DirectVectorAndMathHelperSingleAndMatrix),
        new BuiltinDefinition("Sin", 1, 0, BuiltinType.IndirectVectorAndMathSingle), 
        new BuiltinDefinition("Cos", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Tan", 1, 0, BuiltinType.IndirectVectorAndMathSingle), 
        new BuiltinDefinition("Asin", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Acos", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Atan", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Atan2", 2, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Abs", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Ceiling", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Floor", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Round", 1, 0, BuiltinType.IndirectVectorAndMathSingle),
        new BuiltinDefinition("Add", 2, 0, BuiltinType.VectorAndMatrixOnly),
        new BuiltinDefinition("Subtract", 2, 0, BuiltinType.VectorAndMatrixOnly),
        new BuiltinDefinition("Multiply", 2, 0, BuiltinType.VectorAndMatrixOnly),
        new BuiltinDefinition("Divide", 2, 0, BuiltinType.VectorAndMatrixOnly),
        new BuiltinDefinition("Negate", 1, 0, BuiltinType.VectorAndMatrixOnly),
        new BuiltinDefinition("Dot", 2, 0, BuiltinType.VectorOnly),
        new BuiltinDefinition("Cross", 2, 0, BuiltinType.Vector3Only),
        new BuiltinDefinition("Normalize", 1, 0, BuiltinType.VectorOnly),
        new BuiltinDefinition("Distance", 2, 0, BuiltinType.VectorOnly),
        new BuiltinDefinition("DistanceSquared", 2, 0, BuiltinType.VectorOnly)
    };

    foreach (var def in definitions)
    {
    #>
    public static object <#=def.Name#>(params object[] values)
    {
    <#
    if (def.VectorDirectlySupported || def.MatrixAllowed)
    {
        if (!def.Vector3Only)
        {
        #>
        if (<#for (var i = 0; i < def.Arguments; i++){if (i!=0){#>&&<#}#>values[<#=i#>] is Vector2<#}#>)
        {
            return Vector2.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                (Vector2)values[<#=i #>]
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>);
        }<#}#>

        if (<#for (var i = 0; i < def.Arguments; i++){if (i!=0){#>&&<#}#>values[<#=i#>] is Vector3<#}#>)
        {
            return Vector3.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                (Vector3)values[<#=i #>]
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>);
        }
        <#
        if (!def.Vector3Only)
        {#>
        if (<#for (var i = 0; i < def.Arguments; i++){if (i!=0){#>&&<#}#>values[<#=i#>] is Vector4<#}#>)
        {
            return Vector4.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                (Vector4)values[<#=i #>]
                <#
}
else
{ #>
                Convert.ToSingle(values[<#=i #>])
<# }
} #>);
        }<#}
        
        if (def.MatrixAllowed)
        { #>
        if (<#for (var i = 0; i < def.Arguments; i++){if (i!=0){#>&&<#}#>values[<#=i#>] is Matrix<#}#>)
        {
            return Matrix.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                (Matrix)values[<#=i #>]
                <#
}
else
{ #>
                Convert.ToSingle(values[<#=i #>])
<# }
} #>);
        }
        <# }#>
    <#
    }
    else
    {
        if (!def.Vector3Only)
        {
            #>
        if (<#for (var i = 0; i < def.Arguments; i++)
{
    if (i != 0)
    { #>&&<# } #>values[<#=i #>] is Vector2<# } #>)
        {
            return new Vector2(
                <#=def.UsesHelper ? "MathHelper" : "(float)Math" #>.<#=def.Name #>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{
    if (i != 0)
    { #>,<# }
if (i < def.Arguments)
{ #>
                ((Vector2)values[<#=i #>]).X
                <# }
else
{ #>
                Convert.ToSingle(values[<#=i #>])
                <# }
} #>),
                <#=def.UsesHelper ? "MathHelper" : "(float)Math" #>.<#=def.Name #>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{
    if (i != 0)
    { #>,<# }
if (i < def.Arguments)
{ #>
                ((Vector2)values[<#=i #>]).Y
                <# }
else
{ #>
                Convert.ToSingle(values[<#=i #>])
                <# }
} #>));
        }
        <# } #>
        if (<#for (var i = 0; i < def.Arguments; i++){if (i!=0){#>&&<#}#>values[<#=i#>] is Vector3<#}#>)
        {
            return new Vector3(
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector3)values[<#=i #>]).X
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>),
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector3)values[<#=i #>]).Y
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>),
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector3)values[<#=i #>]).Z
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>));
        }
        <#
        if (!def.Vector3Only)
        {#>
        if (<#for (var i = 0; i < def.Arguments; i++){if (i!=0){#>&&<#}#>values[<#=i#>] is Vector4<#}#>)
        {
            return new Vector4(
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector4)values[<#=i #>]).X
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>),
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector4)values[<#=i #>]).Y
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>),
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector4)values[<#=i #>]).Z
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>),
                <#=def.UsesHelper ? "MathHelper" : "(float)Math"#>.<#=def.Name#>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{ 
if (i!=0){#>,<#}
if (i < def.Arguments)
{ #>
                ((Vector4)values[<#=i #>]).W
                <# } else { #>
                Convert.ToSingle(values[<#=i #>])
                <#}
} #>));
        }
        <#
}
    }
    #>
    <# if (!def.VectorOnly)
{ #>
        if (values[0] is float)
        {
            return <#=def.UsesHelper ? "MathHelper" : "(float)Math" #>.<#=def.Name #>(
            <# for (var i = 0; i < def.Arguments + def.ExtraFloatArguments; i++)
{
    if (i != 0)
    { #>,<# } #>
                Convert.ToSingle(values[<#=i #>])
                <# } #>
);
        }
        <# }#>

        throw new InvalidOperationException("Invalid type for <#=def.Name#>");
    }
    <#
    }

#>

        public static object Transform(params object[] values)
        {
            if (values[0] is Vector2 && values[1] is Matrix)
            {
                return Vector2.Transform(
                    (Vector2)values[0],
                    (Matrix)values[1]);
            }

            if (values[0] is Vector3 && values[1] is Matrix)
            {
                return Vector3.Transform(
                    (Vector3)values[0],
                    (Matrix)values[1]);
            }

            if (values[0] is Vector4 && values[1] is Matrix)
            {
                return Vector4.Transform(
                    (Vector4)values[0],
                    (Matrix)values[1]);
            }

            throw new InvalidOperationException("Invalid type for Transform");
        }
    }
}
<#+

    public enum BuiltinType
    {
        DirectVectorAndMathHelperSingle,
        DirectVectorAndMathHelperSingleAndMatrix,
        DirectVectorAndMathSingle,
        IndirectVectorAndMathHelperSingle,
        IndirectVectorAndMathSingle,
        VectorOnly,
        VectorAndMatrixOnly,
        Vector3Only
    }

    public class BuiltinDefinition
    {
        public string Name { get; set; }
        public int Arguments { get; set; }
        public int ExtraFloatArguments { get; set; }
        public bool VectorDirectlySupported { get; set; }
        public bool UsesHelper { get; set; }
        public bool VectorOnly { get; set; }
        public bool Vector3Only { get; set; }
        public bool MatrixAllowed { get; set; }

        public BuiltinDefinition(string name, int arguments, int extraFloatArguments, BuiltinType type)
        {
            this.Name = name;
            this.Arguments = arguments;
            this.ExtraFloatArguments = extraFloatArguments;
            this.VectorDirectlySupported = type != BuiltinType.IndirectVectorAndMathHelperSingle && type != BuiltinType.IndirectVectorAndMathSingle;
            this.UsesHelper = type == BuiltinType.DirectVectorAndMathHelperSingle
                              || type == BuiltinType.IndirectVectorAndMathHelperSingle
                              || type == BuiltinType.DirectVectorAndMathHelperSingleAndMatrix;
            this.VectorOnly = type == BuiltinType.VectorOnly || type == BuiltinType.Vector3Only || type == BuiltinType.VectorAndMatrixOnly;
            this.Vector3Only = type == BuiltinType.Vector3Only;
            this.MatrixAllowed = type == BuiltinType.DirectVectorAndMathHelperSingleAndMatrix
                                 || type == BuiltinType.VectorAndMatrixOnly;
        }
    }

    #>